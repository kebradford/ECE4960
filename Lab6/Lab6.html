<!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <title>Lab 6</title>
    <style>
      body{
        padding: 0 80px;}
    </style>
</head>
  <body>
    <div id= "header">
      <center><h1> Lab 6 - PID Control</h1></center>
    </div>
    <div id = "navbar">
      <a href="https://kebradford.github.io/ECE4960"><button class="btn"><i class="fa fa-home"></i> Back to Home Page</button></a>
    </div>
    <br>
    <br>
    <center><h2>Objective </h2></center>
    
      <p>Get PID control working with IMU</p>
      <br>
    <br>
    <center><h2>Materials Used</h2></center>
       <ul>
         <li>1 RC Car</li>
         <li>1 Artemis Nano</li>
         <li>1 USB A/C Cable</li>
         <li>2 batteries (car battery, board battery)</li>
         <li>1 Sparkfun motor driver</li>
         <li>3 Qwiic connectors</li>
         <li>2 screwdrivers (flathead and phillips)</li>
         <li>1 wire stripper/cutter</li>
         <li>1 TOF sensor</li>
         <li>1 IMU</li>
       </ul>
    <br>
    <br>


    <center><h2>Procedure</h2></center>
    <p>

      <br>
      <h4>Setting up IMU</h4>
      <br>
      First, I hooked up the IMU to the Artemis board via Qwic connector and used the wire code to scan the i2c bus. I found the sensor at 0x69 as expected. 
      <br>
      <img src="i2c.PNG" alt="i2c">
      <br>
      Playing around with the IMU on my desk, I found that the acceleration data generally hovered around (0, 0, 1000) when laying flat, which is expected for 0 acceleration in the x and y directions and 1g of acceleration in the z direction due to gravity. The magnetometer and gyroscope data hovered around zero as well, again expected as the IMU was not moving. 
      <br>
      <img src="IMU_still.PNG" alt="imu still">
      <br>
      When I started waving the IMU around, I got more erratic data reads from all sensors on the 9 DOF IMU. Acceleration data in particular was much higher. 
      <br>
      <img src="IMU_notstill.PNG" alt="imu not still">
      <br>
      <br>
      <h4>Testing the Accelerometer</h4>
      <br>

      First, I read out just the raw data from the accelerometer and plotted it using the Arduino Serial Plotter. Holding it at {-90, 0, 90}, these were the results 

      <br>
      <img src="unfiltered_pitchroll.PNG" alt="imu not still">
      <br>

      I saw that there was a lot of noise on it, so I did some analysis of the accelerometer X data while lying flat on the table. I found an average value of .205 with a stdev of .4, which I did not find unreasonbly uncalibrated for the sensor. An average value of .2 could correspond with my table not being exactly flat. 
      <br>
      <img src="accnoise.PNG" alt="imu not still">
      <br>
      I next tried tapping at the table while the IMU was sitting still. I found large spikes when this happened. 
      <br>
      <img src="tap_imu.PNG" alt="imu not still">
      <br>
      So I plotted the FFT in python to see the frequencies of the disturbances. 
      <br>
      <img src="frequency_response.PNG" alt="imu not still">
      <br>
      The highest frequency response I observed was at 200 Hz. Using the equations from class to calculate alpha, I set RC to 200 Hz and T to 1/(30ms) (the delay time) to achieve an alpha of .14. I tested this functionality by setting up a rolling filter and seeing the response. I tilted the IMU by 90 degrees and observed the change, which was very smooth after the filter was implemented, and not spiky like before. 

      <code><pre>

    pitch_a = atan2(myICM.accX(), myICM.accZ())*180/M_PI;
    roll_a  = atan2(myICM.accY(), myICM.accZ())*180/M_PI;

    alpha = .14;
    pitch_alpha = (alpha*pitch_a)+((1-alpha)*old_pitch);
    old_pitch = pitch_alpha;
    roll_alpha = (alpha*roll_a)+((1-alpha)*old_roll);
    old_roll = roll_alpha;


      </pre></code>

      <br>
      <br>


      <br>
      <img src="nice_change.PNG" alt="imu not still">
      <br>


    </p>
    <br>
    
  
 
   <a href="#header"><button class="btn"><i class="fa fa-arrow-up"></i>Return to top</button></a>
   </body>
</html>
