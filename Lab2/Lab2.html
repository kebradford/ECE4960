<!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <title> Lab 1</title>
    <style>
      body{
        padding: 0 80px;}
    </style>
</head>
  <body>
    <div id= "header">
      <center><h1> Lab 2 - Bluetooth</h1></center>
    </div>
    <div id = "navbar">
      <a href="https://kebradford.github.io/ECE4960"><button class="btn"><i class="fa fa-home"></i> Back to Home Page</button></a>
    </div>
    <br>
    <br>
    <center><h2>Objective </h2></center>
    
      <p>The goal of this lab was to run Bluetooth between the artemis board and the computer</p>
      <br>
    <br>
    <center><h2>Materials Used</h2></center>
       <ul>
         <li>1 Artemis Nano</li>
         <li>1 USB A/C Cable</li>
         <li>1 Bluetooth USB Adapter</li>
         
       </ul>
    <br>
    <br>
    <center><h2>Procedure</h2></center>
    <p>
      To start with I downloaded the source code found on the course website 
      <a href="https://cei-lab.github.io/ECE4960/Lab2.html">here</a>, which had all the relevant python and c code.
      
      <br>
      I also plugged in the usb to bluetooth adapter we were given in our kits, and reran the commands to install bleak. 
      <br>
      Next, I uploaded the code to the Artemis board from the Arduino IDE, confirming that the blue LED blinked and the serial monitor printed the requisite information

      <br>
      Next, because I read campuswire and remembered that this was a thing with VMs, I ensured I could use USB devices in the VM by enabling them in the settings of the VirtualBox manager
      <br>
      Now, things got a little less clean. After first running main.py in the VM, I got bleak errors. Then, after just running a few more times, I got bluetooth adapter not found issues. After some headscratching and good-ole ECE turning it off and turning it back on again, I found that I had to reconnect the bluetooth module after the VM was already running, else it would not be found. Curious, as this was not the case for the Nano, but the problem was "solved". It finally found my device! I added the robot's address to settings.py as well to speed up the process in the future. 

      <br>
      <h3>Ping Robot</h3>
      Now I moved on to the Ping Robot stage. 
      I simply edited the myRobotTasks() code to run <code>await theRobot.ping()</code>
      <br>
      The pinging worked right off the bat, and I was able to collect data on the round trip time, shown below in these two histograms 
      <br>
      <center>
      <img src="pingratehistogram.PNG" alt="ping rate">
      </center>
      <br>
      Oddly enough, the ping rate went down after a short period of time, shown below 
      <center>
      <img src="pingratetime.PNG" alt="ping rate">
      </center>
      <br>
      However, the average ping rate was around 161ms with a standard deviation of 41ms 
      <br>
      <br>
      The Arduino code shows that l_rcvd (length recieved) is the length of what is being sent, so I tracked down the length in main.py. That tracks back to ece4960robot.py, which shows that ping() redirects to __bleak_ping, which sets the length to be PING.Value (1 byte) + 98 zeros, which results in a total of 99 bytes. 
      <br>
      Given an average of .161 seconds per message, this results in around 614 bytes/sec (or 4919 bits/sec). This is round trip time, however, so one side will send at around 10kb/sec. This is about an order of magnitude slower than our baud rate for serial of 115200 symbols/sec, which adds up for wireless communication. 
      <br>
      <h3>Request Float</h3>
      Next, I went through the process of requesting a float from the device, which I decided to make pi to 5 digits. 
      <br>
      I first started by trying to just write to res_cmd->data directly, but when that errored out on me, I took a look at 
      <code >case START_BYTESTREAM_TX </code>, which showed that there was a tricky type-conversion format that I was unfamiliar with. Copying that, I added  <code >((float *)(res_cmd->data))[0] = 3.14159f;</code>, and changed TODO_VAL to 1. When I tried that, I got the error that it needed 4 bytes, so I changed the number to 4, but that still didn't work. 
      <center>
      <img src="errror_length.PNG" alt="ping rate">
      </center>

      Then, I learned I needed 1 byte for the length and one for the type, and tried that (6). Still, nothing worked. So I tried the suggestion on campuswire to print the raw value of what I was sending, and realized I forgot to add the command_type. 
      <center>
      <img src="error_4bytes.PNG" alt="ping rate">
      </center>
      I went to simpleHandler in main.py and found Commands.GIVE_FLOAT.value. Finally, I added that, et voila. 

      <center>
      <img src="correctfloat.PNG" alt="ping rate">
      </center>

      <code><pre>
        case REQ_FLOAT:
            Serial.println("Going to send a float");

            res_cmd->command_type = GIVE_FLOAT;
            res_cmd->length = 8; 
            ((float *)(res_cmd->data))[0] = 3.14159f;
            
            amdtpsSendData((uint8_t *)res_cmd, 6);
            
            break;

      </pre></code>

      <br>



    </p>
    <br>
    
  
 
   <a href="#header"><button class="btn"><i class="fa fa-arrow-up"></i>Return to top</button></a>
   </body>
</html>
