<!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <title>Lab 4</title>
    <style>
      body{
        padding: 0 80px;}
    </style>
</head>
  <body>
    <div id= "header">
      <center><h1> Lab 4 - Open Loop Control</h1></center>
    </div>
    <div id = "navbar">
      <a href="https://kebradford.github.io/ECE4960"><button class="btn"><i class="fa fa-home"></i> Back to Home Page</button></a>
    </div>
    <br>
    <br>
    <center><h2>Objective </h2></center>
    
      <p>Get the motors running on the robot with our motor controller, simulate in a virtual environment</p>
      <br>
    <br>
    <center><h2>Materials Used</h2></center>
       <ul>
         <li>1 RC Car</li>
         <li>1 Artemis Nano</li>
         <li>1 USB A/C Cable</li>
         <li>2 batteries (car battery, board battery)</li>
         <li>1 Sparkfun motor driver</li>
         <li>1 Qwiic connector</li>
         <li>2 screwdrivers (flathead and phillips)</li>
         <li>1 wire stripper/cutter</li>
       </ul>
    <br>
    <br>
    <center><h2>Procedure</h2></center>
    <p>
      <h3>4A: Open Loop Control (Real)</h3>
      <br>
      First, I connected the Artemis board to the supplied motor driver board using a Qwiic cable 
      <br><br>
      Next, I loaded up the software example "Example1_wire" to scan the i2c bus for a component, and found it at 0x5D.
      <br>
      <img src="i2c.PNG" alt="i2c">
      <br>
      Next, I took apart the RC car by unscrewing the top, disconnecting the control PCB, and cutting all the leads off that. 
      <br><br>
      I stripped the DC motor connector wires and screwed them into the motor controller terminals, and did the same for the battery connector. I did have to do some "refactoring" of the hot glue with a heat gun so the DC motor cables didn't rip off. 
      <br>
      <img src="connections.jpg" alt="connections" width="320" height="240">
      <br>
      Next, I plugged the battery in, installed the SCMD library in Arduino, and pulled up the MotorTest script. I had to change the code a bit, first by adding the correct i2c address as found above, and then by setting i=2 for the number of motors.  They both ran from this script as shown below 
      <br>
      <video width="320" height="240" controls>
      <source src="spinnybois.mp4" type="video/mp4">
      </video>
      <br>
      The next step was to ensure both wheels were spinning at approximately the same speed and get the robot moving independently, in open-loop form, in a straight line. I did this by first setting the two motors to the same forward linear speed and seeing the difference in how fast the two motors spun. 
      Actually, they ended up spinning at pretty much the same speed when I had them on the floor, so I didn't need to adjust them. Here they are set to level "50" out of 255, which was the lowest I could go and get feedback from them. As you can see, the robot travels in a straight line for quite some time. 
      <br>
      <video width="320" height="240" controls>
      <source src="straightLine.mp4" type="video/mp4">
      </video>
      <br>

      <br>
      <code><pre>

        myMotorDriver.setDrive( 1, 1, 50); 
        myMotorDriver.setDrive( 0, 0, 50); 

      </pre></code>

      <br>

      Next, for fun, I decided to see if the robot would respond in open-loop fashion only when it heard my (sad) whistle by combining elements of Lab1. I mainly just ported over the motor code into my lab1 code, with some fiddling with libraries. I was getting some errors about library mismatches, so I selectively commented out libraries until it stopped throwing errors (arduino.h was the culprit)

      <br>
      <code><pre>


#include <arm_math.h>
//#include <Arduino.h>
#include <stdint.h>
#include "SCMD.h"
#include "SCMD_config.h" //Contains #defines for common SCMD register names and values
#include "Wire.h"

//Global variables needed for PDM library
#define pdmDataBufferSize 4096 //Default is array of 4096 * 32bit
uint16_t pdmDataBuffer[pdmDataBufferSize];

//Global variables needed for the FFT in this sketch
float g_fPDMTimeDomain[pdmDataBufferSize * 2];
float g_fPDMFrequencyDomain[pdmDataBufferSize * 2];
float g_fPDMMagnitudes[pdmDataBufferSize * 2];
uint32_t sampleFreq;

//Enable these defines for additional debug printing
#define PRINT_PDM_DATA 0
#define PRINT_FFT_DATA 0

#include <PDM.h> //Include PDM library included with the Aruino_Apollo3 core
AP3_PDM myPDM;   //Create instance of PDM class

//Math library needed for FFT
#define ARM_MATH_CM4

SCMD myMotorDriver;

void setup()
{
  Serial.begin(115200);
  Serial.println("SparkFun PDM Example");
  pinMode(LED_BUILTIN, OUTPUT);


  ///motor driver stuff 
    myMotorDriver.settings.commInterface = I2C_MODE;
    myMotorDriver.settings.I2CAddress = 0x5D;
    while ( myMotorDriver.begin() != 0xA9 ) //Wait until a valid ID word is returned
  {
    Serial.println( "ID mismatch, trying again" );
    delay(500);
  }
  while ( myMotorDriver.ready() == false );
  while ( myMotorDriver.busy() );
  myMotorDriver.enable();
  

  ///////////////////
  if (myPDM.begin() == false) // Turn on PDM with default settings, start interrupts
  {
    Serial.println("PDM Init failed. Are you sure these pins are PDM capable?");
    while (1)
      ;
  }
  Serial.println("PDM Initialized");

  printPDMConfig();
}

void loop()
{
  if (myPDM.available())
  {
    myPDM.getData(pdmDataBuffer, pdmDataBufferSize);

    printLoudest();
    Serial.println("next check");
  }

  // Go to Deep Sleep until the PDM ISR or other ISR wakes us.
  am_hal_sysctrl_sleep(AM_HAL_SYSCTRL_SLEEP_DEEP);
}

//*****************************************************************************
//
// Analyze and print frequency data.
//
//*****************************************************************************
void printLoudest(void)
{
  float fMaxValue;
  uint32_t ui32MaxIndex;
  int16_t *pi16PDMData = (int16_t *)pdmDataBuffer;
  uint32_t ui32LoudestFrequency;

  //
  // Convert the PDM samples to floats, and arrange them in the format
  // required by the FFT function.
  //
  for (uint32_t i = 0; i < pdmDataBufferSize; i++)
  {
    if (PRINT_PDM_DATA)
    {
      Serial.printf("%d\n", pi16PDMData[i]);

    }

    g_fPDMTimeDomain[2 * i] = pi16PDMData[i] / 1.0;
    g_fPDMTimeDomain[2 * i + 1] = 0.0;
  }

  if (PRINT_PDM_DATA)
  {
    Serial.printf("END\n");
  }

  //
  // Perform the FFT.
  //
  arm_cfft_radix4_instance_f32 S;
  arm_cfft_radix4_init_f32(&S, pdmDataBufferSize, 0, 1);
  arm_cfft_radix4_f32(&S, g_fPDMTimeDomain);
  arm_cmplx_mag_f32(g_fPDMTimeDomain, g_fPDMMagnitudes, pdmDataBufferSize);

  if (PRINT_FFT_DATA)
  {
    for (uint32_t i = 0; i < pdmDataBufferSize / 2; i++)
    {
      Serial.printf("%f\n", g_fPDMMagnitudes[i]);
    }

    Serial.printf("END\n");
  }

  //
  // Find the frequency bin with the largest magnitude.
  //
  arm_max_f32(g_fPDMMagnitudes, pdmDataBufferSize / 2, &fMaxValue, &ui32MaxIndex);

  ui32LoudestFrequency = (sampleFreq * ui32MaxIndex) / pdmDataBufferSize;

  if (PRINT_FFT_DATA)
  {
    Serial.printf("Loudest frequency bin: %d\n", ui32MaxIndex);

      
  }

  Serial.printf("Loudest frequency: %d         \n", ui32LoudestFrequency);
      if (ui32LoudestFrequency > 4000) {
        digitalWrite(LED_BUILTIN, HIGH);
        myMotorDriver.setDrive( 1, 1, 70); 
        myMotorDriver.setDrive( 0, 0, 70); 
        //delay(250);
      }
      else { 
        digitalWrite(LED_BUILTIN, LOW);
        myMotorDriver.setDrive( 1, 1, 0); 
        myMotorDriver.setDrive( 0, 0, 0); 
        //delay(250);
      }
}

//*****************************************************************************
// Print PDM configuration data.
***************************************************************************
void printPDMConfig(void)
{
  uint32_t PDMClk;
  uint32_t MClkDiv;
  float frequencyUnits;

  //
  // Read the config structure to figure out what our internal clock is set
  // to.
  //
  switch (myPDM.getClockDivider())
  {
  case AM_HAL_PDM_MCLKDIV_4:
    MClkDiv = 4;
    break;
  case AM_HAL_PDM_MCLKDIV_3:
    MClkDiv = 3;
    break;
  case AM_HAL_PDM_MCLKDIV_2:
    MClkDiv = 2;
    break;
  case AM_HAL_PDM_MCLKDIV_1:
    MClkDiv = 1;
    break;

  default:
    MClkDiv = 0;
  }

  switch (myPDM.getClockSpeed())
  {
  case AM_HAL_PDM_CLK_12MHZ:
    PDMClk = 12000000;
    break;
  case AM_HAL_PDM_CLK_6MHZ:
    PDMClk = 6000000;
    break;
  case AM_HAL_PDM_CLK_3MHZ:
    PDMClk = 3000000;
    break;
  case AM_HAL_PDM_CLK_1_5MHZ:
    PDMClk = 1500000;
    break;
  case AM_HAL_PDM_CLK_750KHZ:
    PDMClk = 750000;
    break;
  case AM_HAL_PDM_CLK_375KHZ:
    PDMClk = 375000;
    break;
  case AM_HAL_PDM_CLK_187KHZ:
    PDMClk = 187000;
    break;

  default:
    PDMClk = 0;
  }

  // Record the effective sample frequency. We'll need it later to print the
  // loudest frequency from the sample.

  sampleFreq = (PDMClk / (MClkDiv * 2 * myPDM.getDecimationRate()));

  frequencyUnits = (float)sampleFreq / (float)pdmDataBufferSize;

}
        

      </pre></code>

      <br>
      <br>
      <video width="320" height="240" controls>
      <source src="whistle_run.mp4" type="video/mp4">
      </video>
      <br>





      <h3>4A: Open Loop Control (Simulated)</h3>
      <br>
      Next, I set up the lab4 simulator the same way I did in lab 3, and started up jupyter labs in a terminal, which brought me to the lab4 jupyter notebook. 
      <br>
      Reading through, I saw it gave examples of both how to get the position of the robot and how to change the linear and angular velocity. At first I was going to use the known position to calculate when I should turn in a square, but open loop control by definition does not use feedback like that 
      <br>
      Therefore, I decided to instead play around with different values for linear/angular velocity and sleep times to make the robot move in a straight line, stop, turn ~90 degrees, and repeat four times. Here's the code as well as a video of that running in the simulation
      <br>
      <img src="squareCode.PNG" alt="connections" width="320" height="240">
      <br>
      <br>
      <video width="320" height="240" controls>
      <source src="square_loop.mp4" type="video/mp4">
      </video>
      <br>


    </p>
    <br>
    
  
 
   <a href="#header"><button class="btn"><i class="fa fa-arrow-up"></i>Return to top</button></a>
   </body>
</html>
